// SPDX-License-Identifier: LGPL-2.1
// Copyright 2021 Daniel Vogelbacher <daniel@chaospixel.com>

use crate::imgop::{raw::rescale, sensor::bayer::BayerPattern, Dim2};
use rayon::prelude::*;

/// Debayer image by using superpixel method.
/// Each output pixel RGB tuple is generated by 4 pixels from input.
/// The result image is 1/4 of size.
///
/// Before debayer, WB coefficents are applied. If you don't won't WB correction,
/// just supply 1.0 as factor.
pub fn debayer_superpixel(
  pixels: &[u16],
  pattern: BayerPattern,
  dim: Dim2,
  black_level: &[f32; 4],
  white_level: &[f32; 4],
  wb_coeff: &[f32; 4],
) -> (Vec<[f32; 3]>, usize, usize) {
  let rgb = pixels
    .par_chunks_exact(dim.w * 2)
    .map(|s| {
      let (r1, r2) = s.split_at(dim.w);
      r1.chunks_exact(2)
        .zip(r2.chunks_exact(2))
        .map(|(a, b)| {
          let p = rescale(&[a[0], a[1], b[0], b[1]], black_level, white_level);
          let mul_r = wb_coeff[0];
          let mul_g = wb_coeff[1];
          let mul_b = wb_coeff[2];
          match pattern {
            BayerPattern::RGGB => [mul_r * p[0], mul_g * (p[1] + p[2]) / 2.0, mul_b * p[3]],
            BayerPattern::BGGR => [mul_r * p[3], mul_g * (p[1] + p[2]) / 2.0, mul_b * p[0]],
            BayerPattern::GBRG => [mul_r * p[2], mul_g * (p[0] + p[3]) / 2.0, mul_b * p[1]],
            BayerPattern::GRBG => [mul_r * p[1], mul_g * (p[0] + p[3]) / 2.0, mul_b * p[2]],
          }
        })
        .collect::<Vec<_>>()
    })
    .flatten()
    .collect();
  (rgb, dim.w >> 1, dim.h >> 1)
}
